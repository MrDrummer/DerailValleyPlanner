@page "/planner"
@* @page "/planner/{EditMode}" *@

@using DerailValleyPlanner.Models
@using DerailValleyPlanner.Data
@using Microsoft.EntityFrameworkCore
@using System.Collections.ObjectModel
@using System.Collections.Specialized
@inject ISnackbar Snackbar
@*
- Will list all Yards and the summary for each (total jobs, wagons, length, mass and money totalled) load and unload
- Allows child component? Or mode that allows selecting a yard to add?
 *@
<MudText Typo="Typo.h3">Journey Planner</MudText>
<MudSwitch @bind-Checked="@ReadOnly">Edit Mode</MudSwitch>
@if (!ReadOnly)
{
    
}
<MudTable
    Items="@_stops"
    T="Stop"
    Dense="true"
    Hover="true"
    CanCancelEdit="true"
    ReadOnly="@(!ReadOnly)"
    @bind-SelectedItem="selectedItem"
    CommitEditTooltip="Commit Edit"
    OnCommitEditClick="@(() => Snackbar.Add("Commit Edit Handler Invoked"))"
    RowEditPreview="BackupItem"
    RowEditCancel="ResetItemToOriginalValues"
    RowEditCommit="ItemHasBeenCommitted"
    ApplyButtonPosition="@TableApplyButtonPosition.End"
    EditButtonPosition="@TableEditButtonPosition.End"
    EditTrigger="@TableEditTrigger.EditButton"
>
    <HeaderContent>
        <MudTh>Index</MudTh>
        <MudTh>Yard</MudTh>
        <MudTh>Type</MudTh>
        <MudTh>Note</MudTh>
        @if (!CurrentlyEditing)
        {
            <MudTh>Mass</MudTh>
            <MudTh>Length</MudTh>
            <MudTh>Wagons</MudTh>
            <MudTh>Pay</MudTh>
        }
        else
        {
            <MudTh>Current Jobs</MudTh>
        }
    </HeaderContent>
    <RowTemplate>
        <MudTd DataLabel="Index">@context.Index</MudTd>
        <MudTd DataLabel="Yard">@context.Yard</MudTd>
        <MudTd DataLabel="Type">@context.Type</MudTd>
        <MudTd DataLabel="Note">@context.Note</MudTd>
        @if (!CurrentlyEditing)
        {
            <MudTd DataLabel="TotalMass">@context.TotalMass</MudTd>
            <MudTd DataLabel="TotalLength">@context.TotalLength</MudTd>
            <MudTd DataLabel="TotalWagons">@context.TotalWagons</MudTd>
            <MudTd DataLabel="TotalPay">@context.TotalPay</MudTd>
        }
        else
        {
            <MudTd DataLabel="CurrentJobs">Jobs</MudTd>
        }
    </RowTemplate>
    <RowEditingTemplate>
        <MudTd DataLabel="Index">
            <MudNumericField Label="Index" @bind-Value="@context.Index"></MudNumericField>
        </MudTd>
        <MudTd DataLabel="Yard">
            <YardSelection @bind-Yard="@context.Yard"></YardSelection>
        </MudTd>
        <MudTd DataLabel="Type">Dropdown</MudTd>
        <MudTd DataLabel="Note">Text box</MudTd>
        <MudTd DataLabel="CurrentJobs">
            @* <JobSelection @bind-Jobs="@context.Jobs" Type="@context.Type" Yard="@context.Yard" Label="Jobs"></JobSelection> *@
        </MudTd>
    </RowEditingTemplate>
    <EditButtonContent Context="button">
        <MudIconButton Size="@Size.Small" Icon="@Icons.Material.Outlined.Edit" Class="pa-0" OnClick="@button.ButtonAction" Disabled="@button.ButtonDisabled" />
    </EditButtonContent>
</MudTable>

@code {
    
    [Inject]
    private PlannerContext PlannerContext { get; set; }
    
    // [Parameter] public string EditMode { get; set; }

    private bool ReadOnly = true;

    private bool CurrentlyEditing = false;
    private Stop selectedItem;
    private Stop EditCache;
    private ObservableCollection<Stop> _stops = new();
    
    protected override async Task OnInitializedAsync()
    {
        await GetStops();
    }

    async Task GetStops()
    {
        await PlannerContext.Stops.OrderBy(s => s.Index).ForEachAsync(s =>
        {
            s.PropertyChanging += ItemOnPropertyChanging;
            _stops.Add(s);
        });

        _stops.CollectionChanged += (sender, args) =>
        {
            if (args.Action != NotifyCollectionChangedAction.Move) return;
            Console.WriteLine($"Item at index {args.OldStartingIndex} moved to index {args.NewStartingIndex}");

            var (oldI, newI) = (args.OldStartingIndex, args.NewStartingIndex);

            var start = newI > oldI ? oldI : newI;

            if (sender is not ObservableCollection<Stop> newItems || newItems.Count == 0) return;
            for (var i = start; i < newItems.Count; i++)
            {
                var item = newItems[i];
                if (item != null && item.Index == i && item.Index != start) return;
                item.Index = i;
            }
        };
    }

    private void BackupItem(object stopObj)
    {
        CurrentlyEditing = true;
        var stop = (Stop)stopObj;
        
        _stops[stop.Index].PropertyChanging -= ItemOnPropertyChanging;

        EditCache = new Stop
        {
            Index = stop.Index,
            StopId = stop.StopId,
            Type = stop.Type,
            Jobs = stop.Jobs,
            Yard = stop.Yard,
            Note = stop.Note
        };
        StateHasChanged();
    }

    private async void ItemHasBeenCommitted(object stopObj)
    {
        CurrentlyEditing = false;
        var oldStop = EditCache;
        var newStop = (Stop)stopObj;
        _stops[oldStop.Index].PropertyChanging += ItemOnPropertyChanging;

        if (oldStop.Index != newStop.Index)
        {
            _stops.Move(oldStop.Index, newStop.Index);
        }
        else
        {
            PlannerContext.Stops.Update(newStop);
        }
        
        await PlannerContext.SaveChangesAsync();
        
        StateHasChanged();
    }

    private void ResetItemToOriginalValues(object stopObj)
    {
        CurrentlyEditing = false;
        var stop = (Stop)stopObj;
        
        stop.Index = EditCache.Index;
        stop.StopId = EditCache.StopId;
        stop.Type = EditCache.Type;
        stop.Jobs = EditCache.Jobs;
        stop.Yard = EditCache.Yard;
        stop.Note = EditCache.Note;
        
        _stops[stop.Index].PropertyChanging += ItemOnPropertyChanging;
        StateHasChanged();
    }

    private void ItemOnPropertyChanging(object? sender, ValueChanged e)
    {
        Console.WriteLine($"{e.OldValue} changed to {e.NewValue}");

        if (sender is not Stop stop) return;
        
        PlannerContext.Stops.Update(stop);
    }
}